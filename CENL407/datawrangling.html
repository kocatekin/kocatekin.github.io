<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Tugberk" />
  <title>Data Wrangling</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Data Wrangling</h1>
<p class="author">Tugberk</p>
</header>
<p><code>{}</code> can be used for multiple purposes and with various
commands. For example; <code>echo a{b,c}</code> will print out
<code>ab ac</code>. You can also use it to make directories,
<code>mkdir a{b,c}</code> command is going to create folders <em>ab</em>
and <em>ac</em>.</p>
<p>You can use asterisk <code>*</code> to list similar stuff. For
example by using <code>ls a*</code> you can list everything that starts
with letter <em>a</em>. However, if there is a folder named
<em>abc</em>, that command is going to list that too. If you want to
list ab and ac, you can use ? as <code>ls a?</code>. This will only list
ab, ac and alike.</p>
<p>You can also use curly brackets for other purposes. For example
<em>convert</em> command is used to convert images into different
formats by using <code>convert image.png image.jpg</code>. By using
curly brackets you can do <code>convert image.{png,jpg}</code>.</p>
<p>You can also use <em>touch</em> command similarly. For example lets
say you have two directories <em>foo</em> and <em>bar</em>. If you want
to create certain directories in both these directories you can use
<code>touch {foo,bar}/{a..j}</code>. Check each directory to see what is
created.</p>
<blockquote>
<p>Remember that each script in the shell works in a <em>subshell</em>.
Therefore if you <em>cd</em> into something in the script, when the
script ends you will not see your <em>pwd</em> differently. It will be
the same. If you want the changes in the script applied to your
situation, use <code>.</code> before running your command.
<code>. ./script</code></p>
</blockquote>
<h2 id="tldr">TLDR</h2>
<p>When we want to see how a command works, we generally have two
options: <em>man</em> and <em>–help</em>. Tldr gives us an option where
it shows the most used flags in color. For simple commands,
<em>tldr</em> can be very helpful. You can use it as follows:
<code>tldr find</code></p>
<h2 id="find">Find</h2>
<p>Find command is a very useful command with a lot of flags. You can
find any file by using this command and do additional stuff on top of
it. For example, <code>find . -name src -type d</code>. This will look
within the directory for the directory src. Here, <em>d</em> represents
directory. You can change it to <em>f</em> to look for files.</p>
<p>There are a lot of flags and options which you can learn by using
<em>tldr</em> or <em>man</em>. You can even apply commands onto files
using find. For example the following command will find files with
<em>tmp</em> extension and delete them.
<code>find . -name "*.tmp" -exec rm {} \;</code> You can also use
<code>rm *.tmp</code> for the same command but the previous example
intends to show that you can run commands on found materials.</p>
<h2 id="grep">Grep</h2>
<p>With find, we can find files but sometimes we want to content of the
file. For that, we use <em>grep</em>. Similar to <em>find</em> there are
a lot of options with grep, but the simplest use is as follows:
<code>grep text file.txt</code>. This will look for the word
<em>text</em> in file.txt.</p>
<blockquote>
<p>There are additional software available for different uses in shell
such as <em>ripgrep (rp)</em>. You can download such applications and
use them if you find them useful. However, keep that in mind that these
are 3rd party applications and there may be some errors not yet
found.</p>
</blockquote>
<h2 id="history">history</h2>
<p>In shells, you may want to see the commands you wrote before.
<em>history</em> commands shows us this. By using <em>tldr</em> again
you can find different uses for this command. However, simply just write
<em>history</em> and you will see your previous commands. If you are
looking for a specific command, you can use <em>grep</em> to find it:
<code>history | grep ffmpeg</code> will help you find the ffmpeg
commands you used.</p>
<h2 id="data-wrangling">Data wrangling</h2>
<p>Any time we use <code>|</code> <em>piping</em> we are actually doing
some kind of data wrangling. We are manipulating the inputs and outputs.
Shell is very useful in this regard. Here, we are going to look at a log
example and try to manipulate it to get information. For that, let’s
learn some applications and concepts.</p>
<h3 id="sed">sed</h3>
<p>Sed is <em>stream editor</em>. It is a somewhat newer version of the
old <em>ed</em>. Although it is a programming language, it is generally
used for <em>searching</em> and <em>replacing</em> stuff in text files.
It is generally used as follows:
<code>sed 's/search/replace/'</code></p>
<h3 id="regex">regex</h3>
<p>Regex (or regexp) is short for <em>regular expressions</em>. It is a
topic on its own. It is a very powerful way to match text. You can use
it for other purposes as well but generally it is used with text.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">&quot;abab&quot;</span> <span class="kw">|</span> <span class="fu">sed</span> <span class="st">&#39;s/[ab]//&#39;</span> <span class="co">#output: bab</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">&quot;abab&quot;</span> <span class="kw">|</span> <span class="fu">sed</span> <span class="st">&#39;s/[ab]//g&#39;</span> <span class="co">#output:</span></span></code></pre></div>
<p>Examples above uses <code>[ab]</code>. That means if a character is a
or b, replace it with something else. In the case of the example above,
it is replacing it with empty space, which means it is deleting it. We
use <em>g</em> when we want to apply the same rule into everything in
that line.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">&quot;abc&quot;</span> <span class="kw">|</span> <span class="fu">sed</span> <span class="st">&#39;s/[ab]//&#39;</span> <span class="co">#output: bc</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">&quot;abc&quot;</span> <span class="kw">|</span> <span class="fu">sed</span> <span class="st">&#39;s/[ab]//g&#39;</span> <span class="co">#output: c</span></span></code></pre></div>
<p>Examples above show this distinction more clearly. In the first line,
since we don’t use <em>g</em>; the rule is going to be run once and
since the first char is one of a or b; it will delete it. However, in
the second line since we use <em>g</em>; it is going to run for both a
and b and deleting them, giving us the output c.</p>
<p>We can also use parenthesis, but that means something different.
Let’s look at it with an example:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">&quot;abcaba&quot;</span> <span class="kw">|</span> <span class="fu">sed</span> <span class="at">-E</span> <span class="st">&#39;s/(ab)//&#39;</span> <span class="co">#output: caba</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">&quot;abcaba&quot;</span> <span class="kw">|</span> <span class="fu">sed</span> <span class="at">-E</span> <span class="st">&#39;s/(ab)//g&#39;</span> <span class="co">#output: ca</span></span></code></pre></div>
<p>Here we use the <em>-E</em> because since <em>sed</em> is an old
application, that flag helps sed to understand more modern regex. Here,
instead of looking for <em>a or b</em> we are looking at <em>ab</em> as
a whole. Since we don’t use <em>g</em>, it worked for once. In the
second line, we use <em>g</em> so that it applies the rule to every
possible occasion.</p>
<p>We can also use or operator when we are trying to match whole
patterns.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">&quot;acababc&quot;</span> <span class="kw">|</span> <span class="fu">sed</span> <span class="at">-E</span> <span class="st">&#39;s/(ab|bc)//g&#39;</span> <span class="co">#output: acc</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">&quot;bcbcbcd&quot;</span> <span class="kw">|</span> <span class="fu">sed</span> <span class="at">-E</span> <span class="st">&#39;s/(ab|bc)//g&#39;</span> <span class="co">#output: d</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="bu">echo</span> <span class="st">&quot;abcadbc&quot;</span> <span class="kw">|</span> <span class="fu">sed</span> <span class="at">-E</span> <span class="st">&#39;s/(ab|bc)//g&#39;</span> <span class="co">#output: cad</span></span></code></pre></div>
<p>Here, when <em>ab</em> is there, it deletes that. It did not have any
opportunities to delete <em>bc</em>. Next lines give a better example.
In the next line, there is no <em>ab</em> but there is <em>bc</em> and
the command works on it. In the third one, you can see both of them
visible. First, all <em>ab</em> matches are deleted and we have
<em>cadbc</em>. Then the <em>bc</em> works and the result is
<em>cad</em>.</p>
<blockquote>
<p>With regular expressions you can solve almost anything, but it can be
very hard and complex. That is why there are <em>regex debuggers</em>
online which can help you to visualize how your regex works on a given
text. It helps with complicated regex. There are many <em>regular
expressions</em> available online for certain tasks, a simple Google
search can help you find them. However, you should always keep in mind
that when you are running a command or anything you found from the
internet, there is a risk that it may not work as expected. Be careful
for edge cases.</p>
</blockquote>
<h3 id="combining-all-together">Combining all together</h3>
<p>There are many useful commands in shell such as <em>sort</em> and
<em>uniq</em>. We are going to use them alongside with others for the
(ssh.log)[https://raw.githubusercontent.com/kocatekin/kocatekin.github.io/main/CENL407/files/ssh.log]
file. From this file, we are going to find usernames who attempted to
login but was unsuccesful. Again, this is just for demonstration
purposes and therefore may not be useful in daily life, but will give an
example of the capabilities of shell.</p>
<p>Let’s start by simple grep commands. When you
<code>cat ssh.log</code> you will see there are a lot of lines. We are
interested in those which are <em>sshd</em> and <em>Disconnected
from</em>.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span> ssh.log <span class="kw">|</span> <span class="fu">grep</span> sshd <span class="kw">|</span> <span class="fu">grep</span> <span class="st">&quot;Disconnected from&quot;</span></span></code></pre></div>
<p>This line outputs those includes these terms. Now, we want to delete
unnecessary things to get the username. For this, let’s talk about
<em>capture group</em>. Those terms we put in parenthesis are called
<em>capture groups</em>. We are going to use this later on.</p>
<p>Let’s carry on.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span> ssh.log <span class="kw">|</span> <span class="fu">grep</span> sshd <span class="kw">|</span> <span class="fu">grep</span> <span class="st">&quot;Disconnected from&quot;</span> <span class="kw">|</span> <span class="fu">sed</span> <span class="at">-E</span> <span class="st">&#39;s/.*Disconnected From//g&#39;</span></span></code></pre></div>
<p>The output is going to be,</p>
<pre><code> invalid user pz 23.102.255.235 port 45534 [preauth]
 authenticating user root 125.65.42.183 port 39167 [preauth]
 invalid user pz 23.102.255.235 port 34854 [preauth]
 invalid user q2server 23.102.255.235 port 52381 [preauth]
 invalid user q2 23.102.255.235 port 41693 [preauth]
 authenticating user root 175.117.145.239 port 29277 [preauth]
 invalid user q2 23.102.255.235 port 59260 [preauth]
 invalid user uftp 175.117.145.239 port 46345 [preauth]
 invalid user q3server 23.102.255.235 port 48571 [preauth]
 authenticating user root 125.65.42.178 port 46580 [preauth]
 invalid user default 175.117.145.239 port 63407 [preauth]
 invalid user q3 23.102.255.235 port 37911 [preauth]
 invalid user q3 23.102.255.235 port 55448 [preauth]
 invalid user admin 63.139.133.35 port 41624 [preauth]
 invalid user qlserver 23.102.255.235 port 44748 [preauth]
 invalid user kiran 63.139.133.35 port 58841 [preauth]
 invalid user gl 23.102.255.235 port 34035 [preauth]
 authenticating user root 61.184.247.12 port 51790 [preauth]
 invalid user octro 63.139.133.35 port 47840 [preauth]
 invalid user gl 23.102.255.235 port 51584 [preauth]
 invalid user qwserver 23.102.255.235 port 40907 [preauth]
 authenticating user root 115.238.245.14 port 46493 [preauth]
 invalid user qw 23.102.255.235 port 58449 [preauth]
 invalid user qw 23.102.255.235 port 47779 [preauth]
 invalid user roserver 23.102.255.235 port 37087 [preauth]
 invalid user ro 23.102.255.235 port 54628 [preauth]
 invalid user ro 23.102.255.235 port 43951 [preauth]
 invalid user ricochetserver 23.102.255.235 port 33278 [preauth]
 invalid user ricochet 23.102.255.235 port 50835 [preauth]
 invalid user ryder 91.134.140.32 port 51162 [preauth]
 invalid user ricochet 23.102.255.235 port 40142 [preauth]
 invalid user matt 91.134.140.32 port 56934 [preauth]
 invalid user rustserver 23.102.255.235 port 57696 [preauth]
 invalid user secret 91.134.140.32 port 34476 [preauth]
 invalid user rust 23.102.255.235 port 47029 [preauth]
 invalid user rust 23.102.255.235 port 36353 [preauth]
 invalid user sampserver 23.102.255.235 port 53909 [preauth]
 invalid user samp 23.102.255.235 port 43221 [preauth]
 invalid user samp 23.102.255.235 port 60777 [preauth]
 invalid user ss3server 23.102.255.235 port 50074 [preauth]
 invalid user ss3 23.102.255.235 port 39391 [preauth]
 invalid user ss3 23.102.255.235 port 56937 [preauth]
 invalid user sbserver 23.102.255.235 port 46251 [preauth]
 authenticating user root 125.65.42.178 port 44726 [preauth]
 invalid user sb 23.102.255.235 port 35566 [preauth]
 authenticating user root 61.184.247.8 port 37153 [preauth]</code></pre>
<p>We see that the next term we need to get rid of is invalid and
authenticating. It is followed by <em>user</em>. For the sake of
simplicity, let’s just write the <em>sed</em> part.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sed</span> <span class="at">-E</span> <span class="st">&#39;s/.*Disconnected from (invalid|authenticating)? user//g&#39;</span></span></code></pre></div>
<p>Now, we use parenthesis because we want the exact match. The ?
indicates this shall run only once. So, if there were two
<em>invalid</em> only the first one would be deleted. Here, from the
text above we see that these words only written once. After that, we
just write user and it is deleted. Here is the result of the first 10
lines.</p>
<pre><code> pz 23.102.255.235 port 45534 [preauth]
 root 125.65.42.183 port 39167 [preauth]
 pz 23.102.255.235 port 34854 [preauth]
 q2server 23.102.255.235 port 52381 [preauth]
 q2 23.102.255.235 port 41693 [preauth]
 root 175.117.145.239 port 29277 [preauth]
 q2 23.102.255.235 port 59260 [preauth]
 uftp 175.117.145.239 port 46345 [preauth]
 q3server 23.102.255.235 port 48571 [preauth]
 root 125.65.42.178 port 46580 [preauth]
</code></pre>
<p>We need to get the username, IP address, port, port number and delete
de preauth.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sed</span> <span class="at">-E</span> <span class="st">&#39;s/.*Disconnected from (invalid|authenticating)? user .* [0-9.]+ port [0-9]+ (\[preauth\])//g&#39;</span></span></code></pre></div>
<p>When we write the command above, everything will be deleted. Let’s go
through them. After user, we put <code>.*</code> which indicates the
term at that place. We know that it is a text, we said just get it. Next
term is <code>[0-9.]+</code>. IP number consists of numbers and a dot. +
at the end tells that this occurs more than once. Remember we used ? so
that we are going to look at it once. We know say that it occurs more
than once, so apply it for every consecutive occurence. Then we just
write port, and after that we do <code>[0-9]+</code>. Here, there is no
<em>dot</em> because port numbers do not have that. Lastly, we use
<code>\</code> symbols because since <code>[ and ]</code> are special
characters we need to escape them.</p>
<p>Right now, we deleted everything so it is useless. Remember that few
lines above we defined something as <em>capture group</em>. We are going
to make our username a capture group, because we can use them in order
to replace. We capture the username by putting it in parenthesis. So;
<code>.*</code> becomes <code>(.*)</code>.</p>
<p>After that, we can refer to it as follows:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sed</span> <span class="at">-E</span> <span class="st">&#39;s/.*Disconnected from (invalid|authenticating)? user (.*) [0-9.]+ port [0-9]+ (\[preauth\])/\2/g&#39;</span></span></code></pre></div>
<p>There are two differences here. One of them is putting
<code>.*</code> into parenthesis and the other is we changed the
<em>replace</em> part to <code>\2</code>. There are 3 capture groups in
this line and we want to see the second one. Therefore, for
<em>replace</em> part we put that and when you run this; you will end up
with:</p>
<pre><code>pz
root
pz
q2server
q2
root
q2
uftp
q3server
root
default
q3
q3
admin
qlserver
kiran
gl
root
octro
gl
qwserver
root
qw
qw
roserver
ro
ro
ricochetserver
ricochet
ryder
ricochet
matt
rustserver
secret
rust
rust
sampserver
samp
samp
ss3server
ss3
ss3
sbserver
root
sb
root</code></pre>
<p>Now, we have a list. By using existing commands in shell, we can get
meaning out of these. First of all, lets sort them. By adding
<code>| sort</code> to the end of the command above, you will end up
with a sorted list. However, you will see that there are replicates. We
can get rid of them by using the command <em>uniq</em>.</p>
<p>Adding <code>| uniq -c</code> after the <em>sort</em> will give us
this result:</p>
<pre><code>      1 admin
      1 default
      2 gl
      1 kiran
      1 matt
      1 octro
      2 pz
      2 q2
      1 q2server
      2 q3
      1 q3server
      1 qlserver
      2 qw
      1 qwserver
      2 ricochet
      1 ricochetserver
      2 ro
      7 root
      1 roserver
      2 rust
      1 rustserver
      1 ryder
      2 samp
      1 sampserver
      1 sb
      1 sbserver
      1 secret
      2 ss3
      1 ss3server
      1 uftp</code></pre>
<p>As you can see, this is not sorted. You can put an additional
<code>| sort</code> to sort it. It will list it from top to bottom, you
can reverse it by using -r flag for sort command.</p>
<p>At this point, you end up with a lot of usernames and how many times
they are used for login attempts. Here, you may want to read only the
usernames and not the numbers. We can use <em>awk</em> for that.</p>
<h3 id="awk">AWK</h3>
<p>AWK is a programming language. It is a <em>column based</em> stream
processor unlike <em>sed</em> which is a <em>stream editor</em>. AWK can
be very complicated and almost anything can be done with it, but we are
going to give very simple examples.</p>
<p>Since it is a column based stream processor, you can reach columns
very easily by using <code>$</code> notation. For example; if we add
<code>| awk '{print $1}'</code> to our long pipe; we are going to see
the numbers. If you change <em>$1</em> into <em>$2</em> you will see the
usernames!</p>
<h3 id="paste">Paste</h3>
<p>Paste is also a built-in command. It merges text. When we do
<em>tldr</em> we can see several usages for paste command. You can try
all of them by writing paste command at the end of the pipeline. For
example, let’s try <code>-sd</code>.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">|</span> <span class="fu">awk</span> <span class="st">&#39;{print $2}&#39;</span> <span class="kw">|</span> <span class="fu">paste</span> <span class="at">-sd,</span></span></code></pre></div>
<p>This will give you the usernames separated by a comma. You can also
change the comma into whatever character you want.</p>
<h3 id="bc">bc</h3>
<p>This command lets you use mathematical operations in shell.
<code>echo "1+2" | bc -l</code> will give you 3 as an output.</p>
<p>Let’s do a simple example which includes everything we learned so
far. As you saw in the echo example above, whatever is in the stream,
<em>bc</em> can do the calculation. So, how can we get the total number
of usernames which are used more than once?</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">|</span> <span class="fu">awk</span> <span class="st">&#39;$1 != 1 {print $1}&#39;</span></span></code></pre></div>
<p>This will give us numbers which are not equal to 1. But it is going
to be in column format. But we know we can write these side by side by
using <em>paste</em> command. What would happen if we use <code>+</code>
instead of <code>,</code>?</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">|</span> <span class="fu">awk</span> <span class="st">&#39;$1 != 1 {print $1}&#39;</span> <span class="kw">|</span> <span class="fu">paste</span> <span class="at">-sd+</span> </span></code></pre></div>
<p>We will end up with;</p>
<pre><code>2+2+2+2+2+2+2+7+2+2+2</code></pre>
<p>We can use <code>bc -l</code> to get the summation!</p>
<h2 id="closing-remarks">Closing remarks</h2>
<p>There are a lot of things which can be done in shell. These are to
give certain easy examples to make you realize the power of shell. You
can even use different programs like <em>R</em> or <em>gnuplot</em> to
manipulate and get information from the outputs we did.</p>
</body>
</html>
