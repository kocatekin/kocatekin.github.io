# Ramblings

Belirli bir sınıfa geldiğimizde, kod ve algoritma işini artık bitirmiş olmamız gerekiyor. Bu, karşımıza gelen her *leetcode* problemini çözebiliyor olmak anlamına gelmiyor, belki en efektif yöntemde de çözemeyiz ancak çözebiliyor olmalıyız. Yani artık temel programlama bitmiş olmalı. Bu bitmiş olmalı ki, artık *domain specific* bilgiler edinmeye başlayalım. Bunlar, bizi diğerlerinden ayıran şeyler olacak aslında.

Örneğin bir sistem düşünelim ve adım adım ilerleyelim. İlk olarak bu sistemi sadece biz kullanacak olalım. Böyle bir durumda kullanıcı hesabına ihtiyacımız yok. Eğer programı sadece biz kullanacaksak, o zaman direkt olarak ekran açılabilir ve orada veritabanı varsa ona bağlantı yapılıp görülebilir. Veritabanına da bir şey eklenecekse eğer, direkt olarak ekleyebiliriz.

Ancak belki de, bilgisayarı başkaları kullanıyordur ve bu programı çift tıklayıp çalıştırdıklarında bir şeyler yapamasınlar isteriz. O zaman, kendimize bir kullanıcı açmamız gerekiyor. Bu kullanıcı için açıkçası veritabanına gerek yok, basit bir `if` komutu ile kullanıcı adı ve şifreyi kontrol ettirebiliriz. Eğer doğruysa, onu istediğimiz sayfaya yönlendiririz. Örneğin, `icerik.html` adresine yönlendiririz. 

Buraya kadar iyi, ancak bir gün biri gelip; biz giriş yaptığımızda nereye yönlendiğimizi gördüyse, o zaman kendisi de şifreyi yazmadan direkt `site/icerik.html` adresine gitmek isteyebilir. O halde, adres çubuğuna bunu yazdığında, sistemimizin aslında bu kullanıcının **giriş yapıp yapmadığını** kontrol etmesi gerekecek. Peki bunu nasıl yapabiliriz? `session` kullanarak yapabiliriz!

Bir kullanıcı, kendi kullanıcı adı ve şifresini yazdığında, eğer bu bilgiler doğruysa, ona özel bir session oluşturabiliriz. Ondan sonra da programımıza deriz ki, *bak şu şu sayfaya girmek isteyen olursa, ona ozel bir session açmış mıyız bir bak*. O halde bu problemi çözmüş olduk. Bu problemi çözerken de session denen kavramı tanıdık.

Programımız güzelmiş, başkaları da kullanmak istedi. Ancak biz sadece kendimiz kullanacağız diye, veritabanında kullanıcıları bile tutmuyorduk. Peki, o zaman artık `if` komutunu direkt olarak kullanmak yerine, bir veritabanı kuralım ve kayıt olan kullanıcıları oraya yazmaya başlayalım. **Kayıt Ol** diye bir sayfa yaparız, oraya yazılan kullanıcı adı ve şifresini de veritabanına yazıveririz. 

İşte şimdi birçok problem karşımıza çıkabilir. Örneğin, bir kişi eğer kayıtlı bir kullanıcı adını seçerse ne olacak? Onu kayıt edemeyiz, her şey karışabilir. O halde, bir kullanıcı kayıt olurken, biz o kullanıcının girdiği kullanıcı adını alıp, veritabanında böyle bir kullanıcı daha önce var mı diye bir kontrol etmeliyiz. Kodumuza bunu ekledik. Artık insanlar gelip kullanıcı adlarıyla giriş yapabilirler.

İnsanlık hali, bazen şifrelerimizi unutuyoruz. Peki, bir kullanıcı şifresini unutursa ne yapacağız? E-posta adresini almadık ki? Alalım o halde. Kayıt olan kullanıcılar artık e-posta adreslerini de girsinler. Ancak şimdi kullanıcı adı kontrolü gibi, bir de e-posta adresini kontrol etmeliyiz. Tamam, kullanıcı adını nasıl kontrol ettiysek, aynı şekilde bunu da kontrol edebiliriz. Ancak, kullanıcılar bazen değişik olurlar. Belki de yalan bir e-posta yazdı. O zaman şöyle yapmak gerekiyor, bu kullanıcı kayıt olduğu zaman ona bir mail atalım, o mailde bir kod ya da link olsun. Ona bassın ki, ben bu kullanıcının aslında o mail adresine sahip olduğunu anlayayım.

Süper. Ancak bu o kadar kolay değil. Örneğin, diyelim ki bir kod göndereceğiz. O kodu nasıl oluşturacağız? Rastgele oluşturalım diyebilirsiniz. Ancak o zaman **random** ve **pseudorandom** kavramları ile tanışmanız gerekiyor. Örneğin çoğu developer bu konuda eksik bilgiye sahip. O yüzden direkt olarak, programlama dili ile gelen default *random* fonksiyonunu kullanıyorlar. Halbuki, bunlar simulasyon, ya da oyunlar için yapılan, deterministik dediğimiz ve belirli bir *seed* üzerinde çalışan algoritmalar. Bunları kullanmamamız gerekiyor. Onun yerine, bizim **csprng** dediğimiz yapıları kullanmamız gerekiyor. İşte şimdi, program yazmaktan daha farklı başka bir bilgi daha öğrendik. Örneğin, Python dilinde yazıyorsanız `secrets` modülü ya da `os.urandom()` kullanmanız gerekecek.

Bu arada, eğer mail atarak bir **link** atmak isterseniz, o linkin de bir token'ı olacak, o token da aynı şekilde üretilmeli.

Güzel. Peki, aslında biz şifreyi veritabanına yazmıştık. Kullanıcı şifremi unuttum derse eğer, şifresini ona geri gönderebiliriz değil mi? Bu da çok büyük bir sorun. Buna **password storage** deniyor. Yine developerların bazen ne yapmaları gerektiğini bilmedikleri bir yere geldik. Çoğu zaman, hazır frameworkler ve modüller kullanıldığı için (*spring security*, *flask-login*, etc) bu problemler otomatik olarak çözülüyor. Ancak bunları bilmek her zaman avantajdır. 

Ne yapmak gerek peki? Özet fonksiyonlarını kullanmak gerekir, ya da *hash* fonksiyonlarını. Bunlar, tek taraflı fonksiyonlardır. Bir girdi verirsiniz, size bir çıktı verir. O çıktıya bakarak asla geri dönemezsiniz. Matematiksel olarak böyle bir yol yoktur. Elbette bu da tek başına yeterli olmaz, o yüzden *salt* adı verdiğimiz (tuzlama) bir metot daha karşımıza çıkıyor. Detaylı bilgi vermiyorum, yine öğrenilmesi gereken bir şey geldi. Salt ve hash fonksiyonlarını kullanarak (ki bazen kısaca bazı kdfleri kullanırız bunun için) şifreleri saklamamız gerekir. Yani öyle ki, sistemin sahibi olarak biz bile veritabanını açtığımız zaman şifre göremeyiz, onun yerine bir *hash* görürüz bu şekilde. 

Bunu da öğrendik. Bu arada, şifre değiştirmek için de bir link atacağız, yine bir token var. Bu token yine *csprng* kullanılarak üretilmeli. Ancak bu yeterli değil, bu linkin sadece **bir kez** kullanım hakkı olmalı. Yoksa bu kişinin maili yanlışlıkla bir yerde açık kaldıysa örneğin, yeniden o linke girip şifre değiştirilebilir!

Aslında şu ana kadar konuştuğumuz şey, sistemin işleviyle **hiç** alakalı değil gördüğünüz gibi. Sadece bir kullanıcının serüveninden bahsettik. İşte, bu kadarlık bölümde bile öğrenilmesi gereken onlarca şey var. Buna ek olarak, bir de **iş** özelinde bilmemiz gereken şeyler olacak. Örneğin bir **ödeme** konusu varsa, bu ödeme konusunda iadeler nasıl olacak? Kaç gün içerisinde iadeler kabul edilecek? Ekranda çıkacak şeylerin hepsinin bu *business logic*lere göre tasarlanması gerekiyor. Daha bunun yanında onlarca şey daha var.

Onları da, başka bir konu ile ilgili başlayarak adım adım ilerleyerek konuşuruz.
